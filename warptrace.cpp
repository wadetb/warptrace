/*
    Warp trace - Warp-level performance analysis for GPUs 
    Copyright (C) 2016  Wade Brainerd
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
void SaveRenderBufferPixels(const char *fileName, unsigned char **pixelsOut)
{
	int				width;
	int				height;
	int				pixelsSize;
	unsigned char	*pixels;
	unsigned char	*flippedPixels;
	int				y;

	glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &width);
	glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &height);

	pixelsSize = width * height * 3;

	pixels = (unsigned char *)malloc(pixelsSize);
	assert(pixels);

	//glReadnPixels( 0, 0, width, height, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, pixelsSize, pixels );
	glReadnPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, pixelsSize, pixels);

	flippedPixels = (unsigned char *)malloc(pixelsSize);
	assert(flippedPixels);

	for (y = 0; y < height; y++)
		memcpy(flippedPixels + (y * width * 3), pixels + ((height - 1 - y) * width * 3), width * 3);

	free(pixels);

	stbi_write_png(fileName, width, height, 3, flippedPixels, width*3);

	if (pixelsOut)
		*pixelsOut = flippedPixels;
	else
		free(flippedPixels);
}


void RenderToFile(const char *fileName, int width, int height, unsigned char **pixelsOut)
{
	GLuint colorTex;
	GLuint depthRb;
	GLuint fb;

	glGenTextures(1, &colorTex);
	glBindTexture(GL_TEXTURE_2D, colorTex);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);

	glGenFramebuffers(1, &fb);
	glBindFramebuffer(GL_FRAMEBUFFER, fb);

	glGenRenderbuffers(1, &depthRb);
	glBindRenderbuffer(GL_RENDERBUFFER, depthRb);
	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, width, height);

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorTex, 0);
	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRb);

	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
		Error("Incomplete framebuffer.");

	glBindFramebuffer(GL_FRAMEBUFFER, fb);

	RenderAtSize(width, height);

	SaveRenderBufferPixels(fileName, pixelsOut);

	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	glDeleteFramebuffers(1, &fb);
	glDeleteRenderbuffers(1, &depthRb);
	glDeleteTextures(1, &colorTex);
}


// 8x8 monochrome font from 32 to 127
unsigned char fontBits[768] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00,
	0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x7e, 0x24, 0x24, 0x7e, 0x24, 0x00,
	0x00, 0x08, 0x3e, 0x28, 0x3e, 0x0a, 0x3e, 0x08, 0x00, 0x62, 0x64, 0x08, 0x10, 0x26, 0x46, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00, 0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00,
	0x00, 0x3c, 0x46, 0x4a, 0x52, 0x62, 0x3c, 0x00, 0x00, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3e, 0x00,
	0x00, 0x3c, 0x42, 0x02, 0x3c, 0x40, 0x7e, 0x00, 0x00, 0x3c, 0x42, 0x0c, 0x02, 0x42, 0x3c, 0x00,
	0x00, 0x08, 0x18, 0x28, 0x48, 0x7e, 0x08, 0x00, 0x00, 0x7e, 0x40, 0x7c, 0x02, 0x42, 0x3c, 0x00,
	0x00, 0x3c, 0x40, 0x7c, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x7e, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00,
	0x00, 0x3c, 0x42, 0x3c, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x3e, 0x02, 0x3c, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x10, 0x20,
	0x00, 0x00, 0x04, 0x08, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x08, 0x04, 0x08, 0x10, 0x00, 0x00, 0x3c, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x00, 0x3c, 0x4a, 0x56, 0x5e, 0x40, 0x3c, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00,
	0x00, 0x7c, 0x42, 0x7c, 0x42, 0x42, 0x7c, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c, 0x00,
	0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x7e, 0x00,
	0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x4e, 0x42, 0x3c, 0x00,
	0x00, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00,
	0x00, 0x02, 0x02, 0x02, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00,
	0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x42, 0x66, 0x5a, 0x42, 0x42, 0x42, 0x00,
	0x00, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00,
	0x00, 0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x52, 0x4a, 0x3c, 0x00,
	0x00, 0x7c, 0x42, 0x42, 0x7c, 0x44, 0x42, 0x00, 0x00, 0x3c, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00,
	0x00, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00,
	0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x5a, 0x24, 0x00,
	0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x00,
	0x00, 0x7e, 0x04, 0x08, 0x10, 0x20, 0x7e, 0x00, 0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0x00, 0x1c, 0x22, 0x78, 0x20, 0x20, 0x7e, 0x00, 0x00, 0x00, 0x38, 0x04, 0x3c, 0x44, 0x3c, 0x00,
	0x00, 0x20, 0x20, 0x3c, 0x22, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x1c, 0x20, 0x20, 0x20, 0x1c, 0x00,
	0x00, 0x04, 0x04, 0x3c, 0x44, 0x44, 0x3c, 0x00, 0x00, 0x00, 0x38, 0x44, 0x78, 0x40, 0x3c, 0x00,
	0x00, 0x0c, 0x10, 0x18, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x3c, 0x44, 0x44, 0x3c, 0x04, 0x38,
	0x00, 0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x00, 0x00, 0x10, 0x00, 0x30, 0x10, 0x10, 0x38, 0x00,
	0x00, 0x04, 0x00, 0x04, 0x04, 0x04, 0x24, 0x18, 0x00, 0x20, 0x28, 0x30, 0x30, 0x28, 0x24, 0x00,
	0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0c, 0x00, 0x00, 0x00, 0x68, 0x54, 0x54, 0x54, 0x54, 0x00,
	0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x00, 0x00, 0x3c, 0x44, 0x44, 0x3c, 0x04, 0x06,
	0x00, 0x00, 0x1c, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x38, 0x40, 0x38, 0x04, 0x78, 0x00,
	0x00, 0x10, 0x38, 0x10, 0x10, 0x10, 0x0c, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x44, 0x44, 0x28, 0x28, 0x10, 0x00, 0x00, 0x00, 0x44, 0x54, 0x54, 0x54, 0x28, 0x00,
	0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x3c, 0x04, 0x38,
	0x00, 0x00, 0x7c, 0x08, 0x10, 0x20, 0x7c, 0x00, 0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x99, 0xa1, 0xa1, 0x99, 0x42, 0x3c
};


struct Plot
{
	int				width;
	int				height;
	unsigned char	*pixels;
};


void PlotPoint( Plot *p, int x, int y, unsigned int color )
{
	unsigned char	*pixel;

	if ( x < 0 || x >= p->width )
		return;

	if ( y < 0 || y >= p->height )
		return;

	pixel = p->pixels + (y * p->width + x) * 3;

	pixel[0] = (color >> 16) & 0xff;
	pixel[1] = (color >>  8) & 0xff;
	pixel[2] = (color >>  0) & 0xff;
}


void PlotRect( Plot *p, int x, int y, int width, int height, unsigned int color )
{
	int	cx;
	int	cy;

	for ( cy = std::max(0, y); cy < std::min(p->height, y+height); cy++ )
		for ( cx = std::max(0, x); cx < std::min(p->width, x+width); cx++ )
			PlotPoint( p, cx, cy, color );
}


void PlotText( Plot *p, int x, int y, unsigned int color, const char *text, ... )
{
	va_list			args;
	char			buffer[512];
	char			*cursor;
	unsigned char	*bits;
	unsigned char	row;
	int				fx;
	int				fy;

	va_start( args, text );
	vsnprintf( buffer, sizeof( buffer ), text, args );
	va_end( args );

	for ( cursor = buffer; *cursor; cursor++ )
	{
		char c = *cursor;

		if ( c < 32 || c > 127 )
			continue;

		bits = &fontBits[(c - 32) * 8];

		for ( fy = 0; fy < 8; fy++ )
		{
			row = bits[fy];

			for ( fx = 0; fx < 8; fx++ )
			{
				if ( row & ((1<<(8-1)) >> fx) )
					PlotPoint( p, x + fx, y + fy, color );
			}
		}

		x += 8;
	}
}


struct STraceHeader
{
	GLuint	pos;
	GLuint	pad[3];
};


struct STracePacket
{
	GLuint	header;
	GLuint	id;
	GLuint	start;
	GLuint	end;
};


#define PKT_WARPID( header ) ( (header >> 16) & 0xffff )
#define PKT_SM( header )     ( (header >>  8) & 0xff   )
#define PKT_STAGE( header )  ( (header >>  5) & 0x7    )
#define PKT_ACTIVE( header ) ( (header      ) & 0x1f   )


#define TRACE_CS 		0
#define TRACE_VS 		1
#define TRACE_TCS 		2
#define TRACE_TES 		3
#define TRACE_GS 		4
#define TRACE_FS 		5
#define TRACE_COUNT 	6


struct STraceStageStats
{
	int				warpCount;

	int				activeBuckets[8];
	float			minActive;
	float			maxActive;
	float			averageActive;
	STracePacket	*minActivePacket;
	STracePacket	*maxActivePacket;

	float			minDuration;
	float			maxDuration;
	float			averageDuration;
	STracePacket	*minDurationPacket;
	STracePacket	*maxDurationPacket;
};


struct STraceStats
{
	int					start;
	int					end;
	int					duration;

	STraceStageStats	stages[TRACE_COUNT];
};


void PlotTrace( const char *fileName, int width, int height, unsigned char *pixels )
{
	STracePacket		*td;
	Plot				plot;
	STraceHeader		*hdr;
	STracePacket		*p;
	STraceStats			stats;
	STraceStageStats	*st;
	int					sm;
	int					warp;
	int					stage;
	int					active;
	int					duration;
	int					x;
	int					span;
	int64_t				start;
	//int					color;
	int					row;
	int64_t				warpStart[1024];
	int64_t				end;
	int					scale;

	plot.width = width;
	plot.height = height;
	plot.pixels = pixels;

	memset( &stats, 0, sizeof( stats ) );
	for ( stage = 0; stage < TRACE_COUNT; stage++ )
	{
		stats.stages[stage].minActive = 32;
		stats.stages[stage].minDuration = FLT_MAX;
	}

	td = (STracePacket *)malloc( TRACE_SIZE );
	assert( td );

	glGetNamedBufferSubData( traceBuffer, 0, TRACE_SIZE, td ); 

	hdr = (STraceHeader *)td;

	p = td + 1;

	for ( warp = 0; warp < array_count( warpStart ); warp++ )
		warpStart[warp] = ~0ull;

	static char *stageNames[TRACE_COUNT] = { "compute", "vertex", "tess control", "tess eval", "geometry", "fragment" };
	static GLuint stageColors[TRACE_COUNT] =
	{
		0x1490e1, // CS
		0xb10e5b, // VS
		0xff4eaa, // TCS
		0x6cbb92, // TES
		0x00ffff, // GS
		0xff6f00, // FS
	};

	while ( (char *)(p + 1) - (char *)td < TRACE_SIZE )
	{
		if ( p - (td + 1) >= hdr->pos )
			break;

		stage = PKT_STAGE( p->header );
		active = PKT_ACTIVE( p->header );
		warp = PKT_WARPID( p->header );
		sm = PKT_SM( p->header );

		assertindex( stage, array_count( stats.stages ) );
		stats.stages[stage].warpCount++;

		if ( active < stats.stages[stage].minActive )
		{
			stats.stages[stage].minActive = (float)active;
			stats.stages[stage].minActivePacket = p;
		}
		if ( active > stats.stages[stage].maxActive )
		{
			stats.stages[stage].maxActive = (float)active;
			stats.stages[stage].maxActivePacket = p;
		}
		stats.stages[stage].activeBuckets[active/4]++;
		stats.stages[stage].averageActive += active;

		start = p->start;
		end = p->end;

		duration = (int)(end - start);

		if ( duration < stats.stages[stage].minDuration )
		{
			stats.stages[stage].minDuration = (float)duration;
			stats.stages[stage].minDurationPacket = p;
		}
		if ( duration > stats.stages[stage].maxDuration )
		{
			stats.stages[stage].maxDuration = (float)duration;
			stats.stages[stage].maxDurationPacket = p;
		}
		stats.stages[stage].averageDuration += duration;

		assertindex( sm, array_count( warpStart ) );
		if ( warpStart[sm] == ~0 )
			warpStart[sm] = start;

		scale = traceZoom;

		x = GLuint( (start - warpStart[sm]) * scale / 10000 );
		span = GLuint( (end - warpStart[sm]) * scale / 10000 ) - x;

		if ( !span )
			span = 1;

		stage = PKT_STAGE( p->header );

		assertindex( stage, TRACE_COUNT );
		GLuint color = stageColors[stage];

		row = sm * 64 + warp;

		if ( traceOneSM )
		{
			if ( sm == 0 )
			{
				PlotRect( &plot, 100 + x, 300 + row * 12, span, 10, color );
				if ( span > 25 )
				{
					PlotText( &plot, 100 + x + 2, 300 + row * 12 + 2, 0, "%d", p->id );
					PlotText( &plot, 100 + x + 1, 300 + row * 12 + 1, 0xffffff, "%d", p->id );
				}
			}
		}
		else
		{
			PlotRect( &plot, 100 + x, 100 + row, span, 1, color );
		}

		p++;
	}

	row = 0;
	for ( stage = 0; stage < TRACE_COUNT; stage++ )
		if ( stats.stages[stage].warpCount )
			row++;

	PlotRect( &plot, plot.width-411, 9, 392, 10+row*48, 0 );
	PlotRect( &plot, plot.width-410, 10, 390, 8+row*48, 0xffffff );

	row = 0;
	for ( stage = 0; stage < TRACE_COUNT; stage++ )
	{
		st = &stats.stages[stage];

		if ( !st->warpCount )
			continue;

		st->averageActive /= st->warpCount;
		st->averageDuration /= st->warpCount;

		PlotRect( &plot, plot.width - 400, 19 + row * 48, 10, 36, stageColors[stage] );
		PlotText( &plot, plot.width - 400, 20 + row * 48, 0, 
			"  %d %s warps", st->warpCount, stageNames[stage] );
		PlotText( &plot, plot.width - 400, 32 + row * 48, 0, 
			"    active threads % 8.1f (%d-%d)", st->averageActive, (int)st->minActive, (int)st->maxActive );
		PlotText( &plot, plot.width - 400, 44 + row * 48, 0, 
			"          duration % 8d (%d-%d)", (int)st->averageDuration, (int)st->minDuration, (int)st->maxDuration );
		row++;
	}

	lodepng::encode( fileName, pixels, width, height, LCT_RGB );

	free( td );
}


